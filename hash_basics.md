
### 1. Концепции криптографии

Основная цель криптографии — обеспечение конфиденциальности, целостности, аутентификации и невозможности отказа от авторства.

*   **Шифрование (Encryption):** Процесс преобразования открытого текста (plaintext) в зашифрованный текст (ciphertext) с использованием ключа.
*   **Дешифрование (Decryption):** Обратный процесс преобразования ciphertext обратно в plaintext с использованием ключа.
*   **Ключ (Key):** Секретная информация, определяющая результат работы алгоритма шифрования/дешифрования.
*   **Симметричное шифрование:** Один и тот же ключ используется для шифрования и дешифрования (например, AES, DES).
*   **Асимметричное шифрование (Криптография с открытым ключом):** Используется пара ключей: открытый (public key) для шифрования и закрытый (private key) для дешифрования (например, RSA).

### 2. Алгоритмы шифрования & Шифры

**Алгоритм шифрования** — это математическая функция, реализующая процесс шифрования/дешифрования. **Шифр** — это конкретная реализация или экземпляр алгоритма.

---

### 3. Data Encryption Standard (DES)

**Тип:** Симметричный, блочный шифр.
**Размер блока:** 64 бита.
**Размер ключа:** 56 бит (изначально 64 бита, но 8 используются для проверки четности).

**Как работает:** DES использует сеть Фейстеля. Данные разбиваются на блоки, и каждый блок проходит 16 идентичных раундов преобразований.

```mermaid
flowchart TD
    A[64-битный блок открытого текста] --> B[Начальная перестановка<br>Initial Permutation - IP]
    B --> C[Разделение на L<sub>0</sub> и R<sub>0</sub> по 32 бита]
    C --> D[Раунд 1]
    D --> E[Раунд 2]
    E --> F[...]
    F --> G[Раунд 16]
    G --> H[Объединение R<sub>16</sub> и L<sub>16</sub>]
    H --> I[Конечная перестановка<br>Final Permutation - FP]
    I --> J[64-битный блок шифротекста]

    subgraph D [Один раунд Фейстеля]
        D_input1[L<sub>i-1</sub>] --> D_output1[R<sub>i-1</sub>]
        D_input2[R<sub>i-1</sub>] --> D_func[Функция F]
        K_sub[Раундовый ключ K<sub>i</sub>] --> D_func
        D_func --> D_xor{XOR}
        D_input1 --> D_xor
        D_xor --> D_output2[L<sub>i</sub>]
    end
```
**Пояснение:**
1.  Блок текста проходит начальную перестановку (IP).
2.  Блок делится на левую (L₀) и правую (R₀) половины.
3.  В каждом из 16 раундов:
    *   Левая половина следующего раунда (Lᵢ) становится правой половиной предыдущего (Rᵢ₋₁).
    *   Правая половина следующего раунда (Rᵢ) вычисляется как `Lᵢ₋₁ XOR F(Rᵢ₋₁, Kᵢ)`, где **F** — это функция, включающая расширение, XOR с раундовым ключом, подстановку (S-boxes) и перестановку (P-box).
4.  После 16 раундов левая и правая части объединяются (причем порядок меняется местами: R₁₆|L₁₆) и проходят через конечную перестановку (FP).

**Недостаток:** Короткий 56-битный ключ уязвим для атаки полным перебором (brute-force). Считается устаревшим.

---

### 4. Advanced Encryption Standard (AES)

**Тип:** Симметричный, блочный шифр.
**Размер блока:** 128 бит.
**Размеры ключа:** 128, 192 или 256 бит.

**Как работает:** AES использует структуру под названием **Сеть подстановок-перестановок (Substitution-Permutation Network, SPN)**. Алгоритм состоит из начального преобразования, нескольких раундов и финального раунда.

```mermaid
flowchart TD
    A[128-битный блок открытого текста] --> B[AddRoundKey<br>XOR с ключом раунда 0]
    B --> C[Раунд 1...N-1]
    C --> D[Финальный раунд N]
    D --> E[128-битный блок шифротекста]

    subgraph C [Стандартный раунд AES]
        C_input --> C_sub[SubBytes<br>Нелинейная замена байтов]
        C_sub --> C_shift[ShiftRows<br>Циклический сдвиг строк]
        C_shift --> C_mix[MixColumns<br>Смешивание столбцов]
        C_mix --> C_key[AddRoundKey<br>XOR с ключом раунда]
        C_key --> C_output
    end

    subgraph D [Финальный раунд AES]
        D_input --> D_sub[SubBytes]
        D_sub --> D_shift[ShiftRows]
        D_shift --> D_key[AddRoundKey]
        D_key --> D_output
    end
```
**Пояснение этапов раунда:**
*   **SubBytes:** Каждый байт состояния заменяется на другой согласно постоянной таблице подстановки (S-box). Это вносит нелинейность.
*   **ShiftRows:** Байты в строках состояния циклически сдвигаются. Нулевая строка не сдвигается, первая сдвигается на 1 и т.д. Это обеспечивает "размазывание" байтов.
*   **MixColumns:** Байты в столбцах состояния преобразуются с использованием линейного преобразования. Каждый столбец рассматривается как полином и умножается на фиксированный полином. Это обеспечивает диффузию.
*   **AddRoundKey:** Текущее состояние объединяется операцией XOR с раундовым ключом, который генерируется из основного ключа.

Количество раундов (N) зависит от размера ключа: 10 для 128-битного, 12 для 192-битного, 14 для 256-битного.

---

### 5. RC4, RC5, RC6

Это семейство потоковых и блочных шифров, созданных Роном Ривестом.

#### RC4 (Rivest Cipher 4)
**Тип:** Симметричный, поточный шифр.
**Как работает:** Генерирует псевдослучайный поток битов (keystream), который затем объединяется с открытым текстом с помощью XOR.

```mermaid
flowchart LR
    A[Секретный ключ] --> B[Инициализация S-Box<br>KSA]
    B --> C[Генерация потока<br>PRGA]
    C --> D[Поток ключей<br>Keystream]
    E[Открытый текст] --> F{XOR}
    D --> F
    F --> G[Шифротекст]
```
**Процесс:**
1.  **KSA (Key-Scheduling Algorithm):** Инициализирует массив S (перестановку чисел 0...255) на основе ключа.
2.  **PRGA (Pseudo-Random Generation Algorithm):** Генерирует каждый байт keystream на основе текущего состояния массива S. Этот байт затем XOR-ится с байтом открытого текста.

**Недостаток:** Уязвим к нескольким атакам, считается ненадежным для современных применений.

---

### 6. Rivest Shamir Adleman (RSA)

**Тип:** Асимметричный алгоритм (для шифрования и цифровой подписи).

**Как работает:** Основан на сложности разложения больших чисел на простые множители.

**Генерация ключей:**
1.  Выбираются два больших простых числа `p` и `q`.
2.  Вычисляется модуль `n = p * q`.
3.  Вычисляется функция Эйлера `φ(n) = (p-1)*(q-1)`.
4.  Выбирается открытая экспонента `e` (обычно 65537), взаимно простая с `φ(n)`.
5.  Вычисляется секретная экспонента `d`, такая что `d * e ≡ 1 mod φ(n)`.
6.  **Открытый ключ:** `(e, n)`
7.  **Закрытый ключ:** `(d, n)`

**Схема шифрования и дешифрования:**
```mermaid
flowchart LR
    subgraph Alice [Алиса]
        A[Открытый текст M] --> A_enc[Шифрование<br> C = M<sup>e</sup> mod n]
        A_enc --> C[Шифротекст C]
    end

    subgraph Bob [Боб]
        B_pub[Пара ключей<br>Публичный: e, n<br>Приватный: d, n] --> B_enc
        C --> B_dec[Дешифрование<br> M = C<sup>d</sup> mod n]
        B_dec --> B_M[Открытый текст M]
    end

    Alice -->|Передает C| Bob
    Bob -->|Публикует e, n| Alice
```
**Пояснение:**
*   Любой, кто хочет отправить сообщение Бобу, шифрует его с помощью его **открытого ключа (e, n)**: `C = Mᵉ mod n`.
*   Расшифровать сообщение может только Боб, используя свой **закрытый ключ (d, n)**: `M = Cᵈ mod n`.

---

### 7. DSA и схемы подписи

**DSA (Digital Signature Algorithm)** — это стандарт для создания **цифровых подписей**.

**Тип:** Асимметричный алгоритм (только для подписи, не для шифрования).

**Как работает (упрощенно):**

```mermaid
flowchart TD
    subgraph Signer [Подписывающая сторона]
        A[Исходное сообщение] --> B[Хеширование<br>Hashing]
        B --> C[Получение дайджеста<br>H]
        C --> D[Генерация подписи<br>Использует приватный ключ x<br>и случайное k<br>Подпись = r, s]
        D --> E[Сообщение + Подпись r,s]
    end

    subgraph Verifier [Верификатор]
        E --> F[Получение сообщения и подписи r,s]
        F --> G[Хеширование<br>Hashing]
        G --> H[Получение дайджеста<br>H]
        H --> I[Верификация подписи<br>Использует публичный ключ y<br>и подпись r,s]
        I --> J{Подпись верна?}
    end
```

**Процесс:**
1.  **Генерация ключей:**
    *   Выбираются параметры: простое `p`, делитель `q` числа `p-1`, и образующий элемент `g` подгруппы порядка `q`.
    *   **Закрытый ключ:** Случайное число `x` (0 < x < q).
    *   **Открытый ключ:** `y = gˣ mod p`.

2.  **Создание подписи:**
    *   Сообщение `M` хешируется, получается хеш-значение `H`.
    *   Генерируется случайное секретное число `k`.
    *   Вычисляются две компоненты подписи:
        *   `r = (gᵏ mod p) mod q`
        *   `s = (k⁻¹ * (H + x*r)) mod q`
    *   Подпись — это пара `(r, s)`.

3.  **Проверка подписи:**
    *   Получатель получает сообщение `M` и подпись `(r, s)`.
    *   Вычисляет хеш `H` от `M`.
    *   Проверяет вычисления, используя открытый ключ `y`. Если проверка прошла успешно, подпись верна.

Цифровая подпись обеспечивает аутентификацию (подписавший владеет закрытым ключом), целостность (любое изменение сообщения приведет к несовпадению хешей) и невозможность отказа от авторства (non-repudiation).