
### 1. Концепции криптографии

Основная цель криптографии — обеспечение конфиденциальности, целостности, аутентификации и невозможности отказа от авторства.

*   **Шифрование (Encryption):** Процесс преобразования открытого текста (plaintext) в зашифрованный текст (ciphertext) с использованием ключа.
*   **Дешифрование (Decryption):** Обратный процесс преобразования ciphertext обратно в plaintext с использованием ключа.
*   **Ключ (Key):** Секретная информация, определяющая результат работы алгоритма шифрования/дешифрования.
*   **Симметричное шифрование:** Один и тот же ключ используется для шифрования и дешифрования (например, AES, DES).
*   **Асимметричное шифрование (Криптография с открытым ключом):** Используется пара ключей: открытый (public key) для шифрования и закрытый (private key) для дешифрования (например, RSA).

### 2. Алгоритмы шифрования & Шифры

**Алгоритм шифрования** — это математическая функция, реализующая процесс шифрования/дешифрования. **Шифр** — это конкретная реализация или экземпляр алгоритма.

---

### 3. Data Encryption Standard (DES)

**Тип:** Симметричный, блочный шифр.
**Размер блока:** 64 бита.
**Размер ключа:** 56 бит (изначально 64 бита, но 8 используются для проверки четности).

**Как работает:** DES использует сеть Фейстеля. Данные разбиваются на блоки, и каждый блок проходит 16 идентичных раундов преобразований.

```mermaid
flowchart TD
    A[64-битный блок открытого текста] --> B[Начальная перестановка<br>Initial Permutation - IP]
    B --> C[Разделение на L<sub>0</sub> и R<sub>0</sub> по 32 бита]
    C --> D[Раунд 1]
    D --> E[Раунд 2]
    E --> F[...]
    F --> G[Раунд 16]
    G --> H[Объединение R<sub>16</sub> и L<sub>16</sub>]
    H --> I[Конечная перестановка<br>Final Permutation - FP]
    I --> J[64-битный блок шифротекста]

    subgraph D [Один раунд Фейстеля]
        D_input1[L<sub>i-1</sub>] --> D_output1[R<sub>i-1</sub>]
        D_input2[R<sub>i-1</sub>] --> D_func[Функция F]
        K_sub[Раундовый ключ K<sub>i</sub>] --> D_func
        D_func --> D_xor{XOR}
        D_input1 --> D_xor
        D_xor --> D_output2[L<sub>i</sub>]
    end
```
**Пояснение:**
1.  Блок текста проходит начальную перестановку (IP).
2.  Блок делится на левую (L₀) и правую (R₀) половины.
3.  В каждом из 16 раундов:
    *   Левая половина следующего раунда (Lᵢ) становится правой половиной предыдущего (Rᵢ₋₁).
    *   Правая половина следующего раунда (Rᵢ) вычисляется как `Lᵢ₋₁ XOR F(Rᵢ₋₁, Kᵢ)`, где **F** — это функция, включающая расширение, XOR с раундовым ключом, подстановку (S-boxes) и перестановку (P-box).
4.  После 16 раундов левая и правая части объединяются (причем порядок меняется местами: R₁₆|L₁₆) и проходят через конечную перестановку (FP).

**Недостаток:** Короткий 56-битный ключ уязвим для атаки полным перебором (brute-force). Считается устаревшим.

---

### 4. Advanced Encryption Standard (AES)

**Тип:** Симметричный, блочный шифр.
**Размер блока:** 128 бит.
**Размеры ключа:** 128, 192 или 256 бит.

**Как работает:** AES использует структуру под названием **Сеть подстановок-перестановок (Substitution-Permutation Network, SPN)**. Алгоритм состоит из начального преобразования, нескольких раундов и финального раунда.

```mermaid
flowchart TD
    A[128-битный блок открытого текста] --> B[AddRoundKey<br>XOR с ключом раунда 0]
    B --> C[Раунд 1...N-1]
    C --> D[Финальный раунд N]
    D --> E[128-битный блок шифротекста]

    subgraph C [Стандартный раунд AES]
        C_input --> C_sub[SubBytes<br>Нелинейная замена байтов]
        C_sub --> C_shift[ShiftRows<br>Циклический сдвиг строк]
        C_shift --> C_mix[MixColumns<br>Смешивание столбцов]
        C_mix --> C_key[AddRoundKey<br>XOR с ключом раунда]
        C_key --> C_output
    end

    subgraph D [Финальный раунд AES]
        D_input --> D_sub[SubBytes]
        D_sub --> D_shift[ShiftRows]
        D_shift --> D_key[AddRoundKey]
        D_key --> D_output
    end
```
**Пояснение этапов раунда:**
*   **SubBytes:** Каждый байт состояния заменяется на другой согласно постоянной таблице подстановки (S-box). Это вносит нелинейность.
*   **ShiftRows:** Байты в строках состояния циклически сдвигаются. Нулевая строка не сдвигается, первая сдвигается на 1 и т.д. Это обеспечивает "размазывание" байтов.
*   **MixColumns:** Байты в столбцах состояния преобразуются с использованием линейного преобразования. Каждый столбец рассматривается как полином и умножается на фиксированный полином. Это обеспечивает диффузию.
*   **AddRoundKey:** Текущее состояние объединяется операцией XOR с раундовым ключом, который генерируется из основного ключа.

Количество раундов (N) зависит от размера ключа: 10 для 128-битного, 12 для 192-битного, 14 для 256-битного.

---

### 5. RC4, RC5, RC6

Это семейство потоковых и блочных шифров, созданных Роном Ривестом.

#### RC4 (Rivest Cipher 4)
**Тип:** Симметричный, поточный шифр.
**Как работает:** Генерирует псевдослучайный поток битов (keystream), который затем объединяется с открытым текстом с помощью XOR.

```mermaid
flowchart LR
    A[Секретный ключ] --> B[Инициализация S-Box<br>KSA]
    B --> C[Генерация потока<br>PRGA]
    C --> D[Поток ключей<br>Keystream]
    E[Открытый текст] --> F{XOR}
    D --> F
    F --> G[Шифротекст]
```
**Процесс:**
1.  **KSA (Key-Scheduling Algorithm):** Инициализирует массив S (перестановку чисел 0...255) на основе ключа.
2.  **PRGA (Pseudo-Random Generation Algorithm):** Генерирует каждый байт keystream на основе текущего состояния массива S. Этот байт затем XOR-ится с байтом открытого текста.

**Недостаток:** Уязвим к нескольким атакам, считается ненадежным для современных применений.

---

### 6. Rivest Shamir Adleman (RSA)

**Тип:** Асимметричный алгоритм (для шифрования и цифровой подписи).

**Как работает:** Основан на сложности разложения больших чисел на простые множители.

**Генерация ключей:**
1.  Выбираются два больших простых числа `p` и `q`.
2.  Вычисляется модуль `n = p * q`.
3.  Вычисляется функция Эйлера `φ(n) = (p-1)*(q-1)`.
4.  Выбирается открытая экспонента `e` (обычно 65537), взаимно простая с `φ(n)`.
5.  Вычисляется секретная экспонента `d`, такая что `d * e ≡ 1 mod φ(n)`.
6.  **Открытый ключ:** `(e, n)`
7.  **Закрытый ключ:** `(d, n)`

**Схема шифрования и дешифрования:**
```mermaid
flowchart LR
    subgraph Alice [Алиса]
        A[Открытый текст M] --> A_enc[Шифрование<br> C = M<sup>e</sup> mod n]
        A_enc --> C[Шифротекст C]
    end

    subgraph Bob [Боб]
        B_pub[Пара ключей<br>Публичный: e, n<br>Приватный: d, n] --> B_enc
        C --> B_dec[Дешифрование<br> M = C<sup>d</sup> mod n]
        B_dec --> B_M[Открытый текст M]
    end

    Alice -->|Передает C| Bob
    Bob -->|Публикует e, n| Alice
```
**Пояснение:**
*   Любой, кто хочет отправить сообщение Бобу, шифрует его с помощью его **открытого ключа (e, n)**: `C = Mᵉ mod n`.
*   Расшифровать сообщение может только Боб, используя свой **закрытый ключ (d, n)**: `M = Cᵈ mod n`.

---

### 7. DSA и схемы подписи

**DSA (Digital Signature Algorithm)** — это стандарт для создания **цифровых подписей**.

**Тип:** Асимметричный алгоритм (только для подписи, не для шифрования).

**Как работает (упрощенно):**

```mermaid
flowchart TD
    subgraph Signer [Подписывающая сторона]
        A[Исходное сообщение] --> B[Хеширование<br>Hashing]
        B --> C[Получение дайджеста<br>H]
        C --> D[Генерация подписи<br>Использует приватный ключ x<br>и случайное k<br>Подпись = r, s]
        D --> E[Сообщение + Подпись r,s]
    end

    subgraph Verifier [Верификатор]
        E --> F[Получение сообщения и подписи r,s]
        F --> G[Хеширование<br>Hashing]
        G --> H[Получение дайджеста<br>H]
        H --> I[Верификация подписи<br>Использует публичный ключ y<br>и подпись r,s]
        I --> J{Подпись верна?}
    end
```

**Процесс:**
1.  **Генерация ключей:**
    *   Выбираются параметры: простое `p`, делитель `q` числа `p-1`, и образующий элемент `g` подгруппы порядка `q`.
    *   **Закрытый ключ:** Случайное число `x` (0 < x < q).
    *   **Открытый ключ:** `y = gˣ mod p`.

2.  **Создание подписи:**
    *   Сообщение `M` хешируется, получается хеш-значение `H`.
    *   Генерируется случайное секретное число `k`.
    *   Вычисляются две компоненты подписи:
        *   `r = (gᵏ mod p) mod q`
        *   `s = (k⁻¹ * (H + x*r)) mod q`
    *   Подпись — это пара `(r, s)`.

3.  **Проверка подписи:**
    *   Получатель получает сообщение `M` и подпись `(r, s)`.
    *   Вычисляет хеш `H` от `M`.
    *   Проверяет вычисления, используя открытый ключ `y`. Если проверка прошла успешно, подпись верна.

Цифровая подпись обеспечивает аутентификацию (подписавший владеет закрытым ключом), целостность (любое изменение сообщения приведет к несовпадению хешей) и невозможность отказа от авторства (non-repudiation).


## 1. Diffie-Hellman (Протокол обмена ключами)

**Назначение:** Безопасный обмен секретным ключом по незащищенному каналу без его передачи.

### Как работает:

```mermaid
flowchart TD
    subgraph Alice [Алиса]
        A[Генерирует случайное<br>секретное число a]
        A --> B[Вычисляет A = g<sup>a</sup> mod p]
        B --> C[Отправляет A Бобу]
        C --> D[Получает B от Боба]
        D --> E[Вычисляет общий ключ<br>K = B<sup>a</sup> mod p]
    end

    subgraph Public [Публичные параметры]
        F[p - большое простое число<br>g - первообразный корень]
    end

    subgraph Bob [Боб]
        G[Генерирует случайное<br>секретное число b]
        G --> H[Вычисляет B = g<sup>b</sup> mod p]
        H --> I[Отправляет B Алисе]
        I --> J[Получает A от Алисы]
        J --> K[Вычисляет общий ключ<br>K = A<sup>b</sup> mod p]
    end

    Public --> Alice
    Public --> Bob
    C --> J
    I --> D
    
    L[Общий секретный ключ K = g<sup>ab</sup> mod p<br>одинаков у обеих сторон!]
    E --> L
    K --> L
```

**Математическая основа:**
- **Секретные значения:** `a` (секрет Алисы), `b` (секрет Боба)
- **Публичные значения:** `p` (простое число), `g` (генератор)
- **Вычисления:**
  - Алиса: `A = gᵃ mod p` → отправляет Бобу
  - Боб: `B = gᵇ mod p` → отправляет Алисе
  - Общий ключ: `K = Bᵃ mod p = Aᵇ mod p = gᵃᵇ mod p`

**Безопасность:** Основана на сложности задачи дискретного логарифмирования.

---

## 2. Функции хеширования

**Назначение:** Преобразование произвольных данных в фиксированную-length "отпечаток" (хеш).

### Общая схема работы:

```mermaid
flowchart TD
    A[Входные данные<br>произвольной длины] --> B[Предварительная обработка<br>дополнение битов]
    B --> C[Добавление длины сообщения]
    C --> D[Инициализация буфера<br>начальных значений]
    D --> E[Обработка блоков<br>по очереди]
    
    subgraph E [Сжатие данных]
        F[Блок данных] --> G[Компрессионная функция]
        H[Текущее состояние хеша] --> G
        G --> I[Новое состояние хеша]
    end
    
    E --> J[Все блоки обработаны?]
    J -->|Нет| E
    J -->|Да| K[Финальное состояние = хеш]
    K --> L[Выход: хеш-значение<br>фиксированной длины]
```

**Свойства хорошей хеш-функции:**
- **Детерминированность:** Один вход → один выход
- **Быстрота вычисления**
- **Устойчивость к коллизиям**
- **Необратимость**

---

## 3. MD4, MD5 семейство

### Общая архитектура MD-семейства:

```mermaid
flowchart TD
    A[Входное сообщение] --> B[Дополнение до длины<br>кратной 512 битам]
    B --> C[Разбиение на блоки<br>по 512 бит]
    C --> D[Инициализация<br>регистров A,B,C,D]
    D --> E[Обработка каждого блока]
    
    subgraph E [Раунды MD5 4 раунда, 16 операций каждый]
        F[Блок данных] --> G[Раунд 1: Функция F]
        G --> H[Раунд 2: Функция G]
        H --> I[Раунд 3: Функция H]
        I --> J[Раунд 4: Функция I]
    end
    
    J --> K[Сложение с предыдущим<br>состоянием]
    K --> L[Следующий блок]
    L --> E
    K --> M[Все блоки обработаны]
    M --> N[Регистры A,B,C,D =<br>финальный хеш 128 бит]
```

**Эволюция MD-семейства:**
- **MD4:** 3 раунда, 128-битный хеш → уязвим
- **MD5:** 4 раунда, 128-битный хеш → также уязвим для коллизий
- **Применение:** Контрольные суммы, проверка целостности

---

## 4. SHA семейство (SHA-1, SHA-256, SHA-512, SHA-3)

### Архитектура SHA-256:

```mermaid
flowchart TD
    A[Сообщение] --> B[Дополнение и разбиение<br>на блоки по 512 бит]
    B --> C[Инициализация 8 регистров<br>A,B,C,D,E,F,G,H]
    C --> D[Обработка каждого блока]
    
    subgraph D [Сжатие блока SHA-256]
        E[Блок данных] --> F[Расширение сообщения<br>16 слов → 64 слова]
        F --> G[64 раунда сжатия]
        
        subgraph G [Один раунд SHA-256]
            H[Регистры A-H] --> I[Вычисление Ch, Maj, ∑0, ∑1]
            I --> J[Вычисление временных<br>переменных T1, T2]
            J --> K[Сдвиг регистров<br>A ← T1 + T2, E ← D + T1]
            K --> L[Обновление регистров]
        end
        
        G --> M[Сложение с предыдущим<br>состоянием]
    end
    
    M --> N[Следующий блок]
    N --> D
    M --> O[Все блоки обработаны]
    O --> P[Конкатенация регистров<br>A,B,C,D,E,F,G,H = 256-битный хеш]
```

**Сравнение SHA семейства:**

| Алгоритм | Длина хеша | Блок | Безопасность |
|----------|------------|------|--------------|
| SHA-1    | 160 бит    | 512  | ❌ Уязвим    |
| SHA-256  | 256 бит    | 512  | ✅ Безопасен |
| SHA-512  | 512 бит    | 1024 | ✅ Безопасен |

---

## 5. SHA-3 (Keccak)

**Особенность:** Использует губчатую конструкцию (sponge construction)

### Схема работы SHA-3:

```mermaid
flowchart TD
    A[Входные данные] --> B[Дополнение 10*1]
    B --> C[Разбиение на блоки<br>r бит каждый r = 1088 для SHA3-256]
    C --> D[Инициализация состояния<br>1600 бит 5×5×64]
    D --> E[Фаза впитывания Absorption]
    
    subgraph E [Губчатая конструкция]
        F[Блок данных] --> G{XOR с состоянием}
        H[Текущее состояние] --> G
        G --> I[Функция перестановки f<br>24 раунда θ,ρ,π,χ,ι]
        I --> J[Обновленное состояние]
    end
    
    E --> K[Все блоки впитаны?]
    K -->|Нет| E
    K -->|Да| L[Фаза выжимания Squeezing]
    
    subgraph L [Генерация выхода]
        M[Применить f к состоянию] --> N[Взять r бит из состояния]
        N --> O[Нужной длины хеша?]
        O -->|Нет| M
        O -->|Да| P[Финальный хеш]
    end
```

**Преимущества SHA-3:**
- Отличная от SHA-2 математическая основа
- Устойчивость к атакам, эффективным против SHA-2
- Гибкость (можно получать хеш любой длины)

---

## 6. HMAC (Hash-based Message Authentication Code)

**Назначение:** Аутентификация сообщений с использованием хеш-функций и секретного ключа.

### Схема работы HMAC:

```mermaid
flowchart TD
    A[Секретный ключ K] --> B{Длина ключа ><br>размер блока?}
    B -->|Да| C[Хешировать ключ K]
    B -->|Нет| D[Дополнить ключ нулями]
    C --> E[Ключ нужной длины]
    D --> E
    
    E --> F[Вычислить ipad = 0x36<br>и opad = 0x5C повторенные]
    F --> G[K ⊕ ipad]
    F --> H[K ⊕ opad]
    
    I[Сообщение M] --> J[Конкатенация: K ⊕ ipad || M]
    J --> K[Хешировать внутренний<br>результат: H K ⊕ ipad || M]
    K --> L[Конкатенация: K ⊕ opad || внутренний хеш]
    L --> M[Хешировать финальный<br>результат: H K ⊕ opad || внутренний хеш]
    M --> N[HMAC результат]
```

**Математическая формула:**
```
HMAC(K, M) = H( (K ⊕ opad) || H( (K ⊕ ipad) || M ) )
```

**Применение:**
- Аутентификация API запросов
- Проверка целостности и подлинности сообщений
- Веб-токены

---

## 7. PREMID-6

**Примечание:** PREMID-6 не является стандартным криптографическим алгоритмом. Возможно, имеется в виду:

- **PRINCE** - блочный шифр с низкой задержкой
- **PRIDE** - легковесный блочный шифр  
- **Опечатка** в оригинальном вопросе

Если уточните, что именно имелось в виду под PREMID-6, я смогу дать более точное объяснение с диаграммами.

Все представленные схемы демонстрируют фундаментальные принципы работы современных криптографических систем, обеспечивающих безопасность цифровых коммуникаций.